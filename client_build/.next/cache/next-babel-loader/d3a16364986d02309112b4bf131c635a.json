{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nexport var baseActionOption = {\n  data: null,\n  mutate: function mutate() {},\n  notice: function notice() {},\n  query: function query() {},\n  setData: function setData() {},\n  store: {}\n};\nvar modelNameList = [];\nexport var modelFactory = function modelFactory(name, state, actions) {\n  if (modelNameList.includes(name)) {\n    throw Error(\"model Name duplicate: \".concat(name));\n  }\n\n  modelNameList.push(name);\n  return {\n    name: name,\n    state: _objectSpread({}, state, {\n      fetchLoad: {},\n      fetchError: {}\n    }),\n    actions: actions\n  };\n};\nexport function mergeModel(model, name, state, actions) {\n  Object.keys(model.state).forEach(function (value) {\n    // @ts-ignore\n    if ((state === null || state === void 0 ? void 0 : state[value]) && !['fetchError', 'fetchLoad'].includes(value)) {\n      throw new Error(\"mergeModel: state duplicate:: key \".concat(value));\n    }\n  });\n  Object.keys(model.actions).forEach(function (value) {\n    // @ts-ignore\n    if (actions === null || actions === void 0 ? void 0 : actions[value]) {\n      throw new Error(\"mergeModel: action duplicate:: key \".concat(value));\n    }\n  });\n  var mergeName = \"\".concat(name, \"_with_\").concat(model.name);\n\n  if (modelNameList.includes(mergeName)) {\n    throw Error(\"model Name duplicate: \".concat(mergeName));\n  }\n\n  return {\n    name: mergeName,\n    state: _objectSpread({}, model.state, {}, state),\n    actions: _objectSpread({}, model.actions, {}, actions)\n  };\n}\nexport function mergeTwoModel(model, modelT) {\n  Object.keys(model.state).forEach(function (value) {\n    var _modelT$state;\n\n    // @ts-ignore\n    if (((_modelT$state = modelT.state) === null || _modelT$state === void 0 ? void 0 : _modelT$state[value]) && !['fetchError', 'fetchLoad'].includes(value)) {\n      throw new Error(\"mergeTwoModel: state duplicate:: key \".concat(value));\n    }\n  });\n  Object.keys(model.actions).forEach(function (value) {\n    var _modelT$actions;\n\n    // @ts-ignore\n    if (modelT === null || modelT === void 0 ? void 0 : (_modelT$actions = modelT.actions) === null || _modelT$actions === void 0 ? void 0 : _modelT$actions[value]) {\n      throw new Error(\"mergeTwoModel: action duplicate:: key \".concat(value));\n    }\n  });\n  var mergeName = \"\".concat(model.name, \"_and_\").concat(modelT.name);\n\n  if (modelNameList.includes(mergeName)) {\n    throw Error(\"model Name duplicate: \".concat(mergeName));\n  }\n\n  return {\n    name: mergeName,\n    state: _objectSpread({}, model.state, {}, modelT.state),\n    actions: _objectSpread({}, model.actions, {}, modelT.actions)\n  };\n}\nexport var mergeThreeModel = function mergeThreeModel(modelA, modelB, modelC) {\n  return mergeTwoModel(mergeTwoModel(modelA, modelB), modelC);\n};\nexport var mergeListModel = function mergeListModel(modelList) {\n  return modelList.slice(1).reduce(function (acc, model) {\n    return mergeTwoModel(acc, model);\n  }, modelList[0]);\n};\nvar initList = [];\nexport var initModel = function initModel(model, initState) {\n  if (initList.includes(model.name)) return;\n  initList.push(model.name);\n  model.state = _objectSpread({}, model.state, {}, initState);\n}; // const model = modelFactory({}, {\n//   ss: {\n//     eee: (value: string, option) => {\n//     }\n//   }\n// })\n//\n// useStoreModel(ModuleEnum.Test, model).actions.ss.eee('')\n// export function mergeIntoModel(originModel, name, innerModel) {\n//\n// }\n// const _model = mergeTwoModel(modelFactory({\n//   t1: ''\n// }, {\n// }), modelFactory({\n//   t3: ''\n// }, {\n// }))\n//\n// mergeModel(_model, {\n//   t2: ''\n// }, {\n// })","map":null,"metadata":{},"sourceType":"module"}