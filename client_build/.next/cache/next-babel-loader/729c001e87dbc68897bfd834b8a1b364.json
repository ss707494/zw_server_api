{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport const baseActionOption = {\n  data: null,\n  mutate: () => {},\n  notice: () => {},\n  query: () => {},\n  setData: () => {},\n  store: {}\n};\nconst modelNameList = [];\nexport const modelFactory = (name, state, actions) => {\n  if (modelNameList.includes(name)) {\n    throw Error(`model Name duplicate: ${name}`);\n  }\n\n  modelNameList.push(name);\n  return {\n    name,\n    state: _objectSpread({}, state, {\n      fetchLoad: {},\n      fetchError: {}\n    }),\n    actions\n  };\n};\nexport function mergeModel(model, name, state, actions) {\n  Object.keys(model.state).forEach(value => {\n    // @ts-ignore\n    if ((state === null || state === void 0 ? void 0 : state[value]) && !['fetchError', 'fetchLoad'].includes(value)) {\n      throw new Error(`mergeModel: state duplicate:: key ${value}`);\n    }\n  });\n  Object.keys(model.actions).forEach(value => {\n    // @ts-ignore\n    if (actions === null || actions === void 0 ? void 0 : actions[value]) {\n      throw new Error(`mergeModel: action duplicate:: key ${value}`);\n    }\n  });\n  const mergeName = `${name}_with_${model.name}`;\n\n  if (modelNameList.includes(mergeName)) {\n    throw Error(`model Name duplicate: ${mergeName}`);\n  }\n\n  return {\n    name: mergeName,\n    state: _objectSpread({}, model.state, {}, state),\n    actions: _objectSpread({}, model.actions, {}, actions)\n  };\n}\nexport function mergeTwoModel(model, modelT) {\n  Object.keys(model.state).forEach(value => {\n    var _modelT$state;\n\n    // @ts-ignore\n    if (((_modelT$state = modelT.state) === null || _modelT$state === void 0 ? void 0 : _modelT$state[value]) && !['fetchError', 'fetchLoad'].includes(value)) {\n      throw new Error(`mergeTwoModel: state duplicate:: key ${value}`);\n    }\n  });\n  Object.keys(model.actions).forEach(value => {\n    var _modelT$actions;\n\n    // @ts-ignore\n    if (modelT === null || modelT === void 0 ? void 0 : (_modelT$actions = modelT.actions) === null || _modelT$actions === void 0 ? void 0 : _modelT$actions[value]) {\n      throw new Error(`mergeTwoModel: action duplicate:: key ${value}`);\n    }\n  });\n  const mergeName = `${model.name}_and_${modelT.name}`;\n\n  if (modelNameList.includes(mergeName)) {\n    throw Error(`model Name duplicate: ${mergeName}`);\n  }\n\n  return {\n    name: mergeName,\n    state: _objectSpread({}, model.state, {}, modelT.state),\n    actions: _objectSpread({}, model.actions, {}, modelT.actions)\n  };\n}\nexport const mergeThreeModel = (modelA, modelB, modelC) => {\n  return mergeTwoModel(mergeTwoModel(modelA, modelB), modelC);\n};\nexport const mergeListModel = modelList => {\n  return modelList.slice(1).reduce((acc, model) => mergeTwoModel(acc, model), modelList[0]);\n};\nconst initList = [];\nexport const initModel = (model, initState) => {\n  if (initList.includes(model.name)) return;\n  initList.push(model.name);\n  model.state = _objectSpread({}, model.state, {}, initState);\n}; // const model = modelFactory({}, {\n//   ss: {\n//     eee: (value: string, option) => {\n//     }\n//   }\n// })\n//\n// useStoreModel(ModuleEnum.Test, model).actions.ss.eee('')\n// export function mergeIntoModel(originModel, name, innerModel) {\n//\n// }\n// const _model = mergeTwoModel(modelFactory({\n//   t1: ''\n// }, {\n// }), modelFactory({\n//   t3: ''\n// }, {\n// }))\n//\n// mergeModel(_model, {\n//   t2: ''\n// }, {\n// })","map":{"version":3,"sources":["D:/code/zw/zw_client_web/utils/ModelAction/modelUtil.ts"],"names":["baseActionOption","data","mutate","notice","query","setData","store","modelNameList","modelFactory","name","state","actions","includes","Error","push","fetchLoad","fetchError","mergeModel","model","Object","keys","forEach","value","mergeName","mergeTwoModel","modelT","mergeThreeModel","modelA","modelB","modelC","mergeListModel","modelList","slice","reduce","acc","initList","initModel","initState"],"mappings":"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","sourcesContent":["\r\ntype ModelFactory<N = ''> = <T, E extends ModelActionObjHelp<any, T & FetchObj>>(name: string, state: T, actions: E) => ModelData<T & FetchObj, E>\r\n\r\nexport const baseActionOption: BaseModelActionOption = {\r\n  data: null,\r\n  mutate: () => {},\r\n  notice: () => {},\r\n  query: () => {},\r\n  setData: () => {},\r\n  store: {}\r\n}\r\n\r\nconst modelNameList:string[] = []\r\nexport const modelFactory: ModelFactory = (name, state, actions) => {\r\n  if (modelNameList.includes(name)) {\r\n    throw Error(`model Name duplicate: ${name}`)\r\n  }\r\n  modelNameList.push(name)\r\n  return {\r\n    name,\r\n    state: {\r\n      ...state,\r\n      fetchLoad: {},\r\n      fetchError: {},\r\n    },\r\n    actions,\r\n  }\r\n}\r\n\r\nexport function mergeModel<A extends FetchObj, B extends ModelActionObjHelp<any, A>, C, D extends ModelActionObjHelp<any, A & C>>(model: {\r\n  state: A\r\n  actions: B\r\n  name: string\r\n}, name: string, state: C, actions: D): {\r\n  state: A & C\r\n  actions: B & D & {\r\n    [key in keyof B]: ModelAction<any, A>\r\n  } & {\r\n    [key in keyof D]: ModelAction<any, A & C>\r\n  }\r\n  name: string\r\n} {\r\n  Object.keys(model.state).forEach(value => {\r\n    // @ts-ignore\r\n    if (state?.[value] && !['fetchError', 'fetchLoad'].includes(value)) {\r\n      throw new Error(`mergeModel: state duplicate:: key ${value}`)\r\n    }\r\n  })\r\n  Object.keys(model.actions).forEach(value => {\r\n    // @ts-ignore\r\n    if (actions?.[value]) {\r\n      throw new Error(`mergeModel: action duplicate:: key ${value}`)\r\n    }\r\n  })\r\n  const mergeName = `${name}_with_${model.name}`\r\n  if (modelNameList.includes(mergeName)) {\r\n    throw Error(`model Name duplicate: ${mergeName}`)\r\n  }\r\n\r\n  return {\r\n    name: mergeName,\r\n    state: {\r\n      ...model.state,\r\n      ...state,\r\n    },\r\n    actions: {\r\n      ...model.actions,\r\n      ...actions,\r\n    },\r\n  }\r\n}\r\n\r\nexport function mergeTwoModel<A, B extends ModelActionObjHelp<any, A>, C, D extends ModelActionObjHelp<any, C>>(model: {\r\n  state: A\r\n  actions: B\r\n  name: string\r\n}, modelT: {\r\n  state: C\r\n  actions: D\r\n  name: string\r\n}): {\r\n  name: string\r\n  state: A & C\r\n  actions: B & D & {\r\n    [key in keyof B]: ModelAction\r\n  } & {\r\n    [key in keyof D]: ModelAction\r\n  }\r\n} {\r\n  Object.keys(model.state).forEach(value => {\r\n    // @ts-ignore\r\n    if (modelT.state?.[value] && !['fetchError', 'fetchLoad'].includes(value)) {\r\n      throw new Error(`mergeTwoModel: state duplicate:: key ${value}`)\r\n    }\r\n  })\r\n  Object.keys(model.actions).forEach(value => {\r\n    // @ts-ignore\r\n    if (modelT?.actions?.[value]) {\r\n      throw new Error(`mergeTwoModel: action duplicate:: key ${value}`)\r\n    }\r\n  })\r\n  const mergeName = `${model.name}_and_${modelT.name}`\r\n  if (modelNameList.includes(mergeName)) {\r\n    throw Error(`model Name duplicate: ${mergeName}`)\r\n  }\r\n\r\n  return {\r\n    name: mergeName,\r\n    state: {\r\n      ...model.state,\r\n      ...modelT.state,\r\n    },\r\n    actions: {\r\n      ...model.actions,\r\n      ...modelT.actions,\r\n    },\r\n  }\r\n}\r\n\r\nexport const mergeThreeModel = <A extends FetchObj, T extends ModelActionObjHelp<any, A>, B extends FetchObj, O extends ModelActionObjHelp<any, B>, C extends FetchObj, P extends ModelActionObjHelp<any, C>>(modelA: ModelData<A, T>, modelB: ModelData<B, O>, modelC: ModelData<C, P>): {\r\n  name: string\r\n  state: A & B & C\r\n  actions: T & O & P & {\r\n    [key in keyof T]: ModelAction\r\n  } & {\r\n    [key in keyof O]: ModelAction\r\n  } & {\r\n    [key in keyof P]: ModelAction\r\n  }\r\n} => {\r\n  return mergeTwoModel(mergeTwoModel(modelA, modelB), modelC)\r\n}\r\n\r\nexport const mergeListModel = (modelList: ModelData<any, any>[]) => {\r\n  return modelList.slice(1).reduce((acc, model) => mergeTwoModel(acc, model), modelList[0])\r\n}\r\n\r\nconst initList: string[] = []\r\nexport const initModel = <T extends FetchObj, E extends ModelActionObjHelp<any, T>>(model: ModelData<T, E>, initState: Partial<T>) => {\r\n  if (initList.includes(model.name)) return\r\n  initList.push(model.name)\r\n  model.state = {\r\n    ...model.state,\r\n    ...initState,\r\n  }\r\n}\r\n\r\n// const model = modelFactory({}, {\r\n//   ss: {\r\n//     eee: (value: string, option) => {\r\n//     }\r\n//   }\r\n// })\r\n//\r\n// useStoreModel(ModuleEnum.Test, model).actions.ss.eee('')\r\n\r\n// export function mergeIntoModel(originModel, name, innerModel) {\r\n//\r\n// }\r\n\r\n// const _model = mergeTwoModel(modelFactory({\r\n//   t1: ''\r\n// }, {\r\n// }), modelFactory({\r\n//   t3: ''\r\n// }, {\r\n// }))\r\n//\r\n// mergeModel(_model, {\r\n//   t2: ''\r\n// }, {\r\n// })\r\n"]},"metadata":{},"sourceType":"module"}